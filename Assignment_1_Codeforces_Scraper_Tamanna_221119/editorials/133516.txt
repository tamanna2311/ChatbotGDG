Thank you all for participating in the round!We apologize for the wrong checker in problem E at the beginning of the contest, as well as the weak tests in problem B. To be honest, all the hacked submissions have similar logic and codes in B, which made me suspicious. Anyway, we are sorry for the inconvenience! >_< Rating Predictions     A B C D E F G H I     Error_Yuan 800 1200 1600 2100 2300 2600 3000 3400 3500   sszcdjr 800 1100 1600 2000 2300 2600 2900 3300 3500   wyrqwq 800 1000 1400 2200 2300 2600 3000 3500 3500   Otomachi_Una 800 1000 1600 2200 2400 2600 3200 3500 3500   dXqwq 900 1100 1700 2200 2400 2600 3200 3500 3500   Kubic 800 1000 1600 2400 2200 2800 3000 3500 3300   wsc2008qwq 800 1100 1600 1900 2200 2700 3100       chromate00 800 1000 1600 1900             rui_er 800 1000 1500 1800 2200 2500 3000       abc864197532 800 1100 1600 2200 2300 2500 2900             A B C D E F G H I     Average 810  1060  1580  2090  2289 2611  3033  3450  3467    Actual 800  1100  1700  1900  2100  2500  3000  3500  3400 (Thank you, rainboy)    2029A - SetAuthor: Otomachi_UnaFirst Blood: Benq at 00:00:51 HintGreedy from small to large. SolutionWe can delete the numbers from small to large. Thus, previously removed numbers will not affect future choices (if ğ‘¥<ğ‘¦x<y, then ğ‘¥x cannot be a multiple of ğ‘¦y). So an integer ğ‘¥x (ğ‘™â‰¤ğ‘¥â‰¤ğ‘Ÿlâ‰¤xâ‰¤r) can be removed if and only if ğ‘˜â‹…ğ‘¥â‰¤ğ‘Ÿkâ‹…xâ‰¤r, that is, ğ‘¥â‰¤âŒŠğ‘Ÿğ‘˜âŒ‹xâ‰¤âŒŠrkâŒ‹. The answer is max(âŒŠğ‘Ÿğ‘˜âŒ‹âˆ’ğ‘™+1,0)max(âŒŠrkâŒ‹âˆ’l+1,0).Time complexity: îˆ»(1)O(1) per test case. Code (C++)#include <bits/stdc++.h>
#define all(s) s.begin(), s.end()
using namespace std;
using ll = long long;
using ull = unsigned long long;
 
const int _N = 1e5 + 5;
 
int T;
 
void solve() {
	int l, r, k; cin >> l >> r >> k;
	cout << max(r / k - l + 1, 0) << endl;
	return;
}
 
int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> T;
	while (T--) {
		solve();
	}
} Code (Python 3)for _ in range(int(input())):
    l, r, k = map(int, input().split())
    print(max(r // k - l + 1, 0)) Rate the Problem Amazing problem: 




35





 Good problem: 

    


147



 Average problem: 

    


119



 Bad problem: 

    


11



 Didn't solve: 

    


18



 2029B - ReplacementAuthor: wyrqwqFirst Blood: Benq at 00:02:30 Hint(ğŸ¶ğŸ·01 or ğŸ·ğŸ¶10 exists) âŸºâŸº (both ğŸ¶0 and ğŸ·1 exist). SolutionEach time we do an operation, if ğ‘ s consists only of ğŸ¶0 or ğŸ·1, we surely cannot find any valid indices. Otherwise, we can always perform the operation successfully. In the ğ‘–i-th operation, if ğ‘¡ğ‘–=ğŸ¶ti=0, we actually decrease the number of ğŸ·1-s by 11, and vice versa. Thus, we only need to maintain the number of ğŸ¶0-s and ğŸ·1-s in ğ‘ s. If any of them falls to 00 before the last operation, the answer is NO, otherwise, the answer is YES.Time complexity: îˆ»(ğ‘›)O(n) per test case. Code (C++)#include <bits/stdc++.h>
#define all(s) s.begin(), s.end()

using namespace std;
using ll = long long;

const int _N = 1e5 + 5;

void solve() {
	int n; cin >> n;
	string s, t; cin >> s >> t;
	int cnt0 = count(all(s), '0'), cnt1 = n - cnt0;
	for (int i = 0; i < n - 1; i++) {
		if (cnt0 == 0 || cnt1 == 0) {
			cout << "NO" << '\n';
			return;
		}
		if (t[i] == '1') cnt0--;
		else cnt1--;
	}
	cout << "YES" << '\n';
}

int main() {
	int T; cin >> T;
	while (T--) {
		solve();
	}
} Code (Python 3)for _ in range(int(input())):
    n = int(input())
    s = input()
    one = s.count("1")
    zero = s.count("0")
    ans = "YES"
    for ti in input():
        if one == 0 or zero == 0:
            ans = "NO"
            break
        one -= 1
        zero -= 1
        if ti == "1":
            one += 1
        else:
            zero += 1
    print(ans) Rate the Problem Amazing problem: 

    


64



 Good problem: 

    


217



 Average problem: 

    


26



 Bad problem: 

    


46



 Didn't solve: 

    


21



 2029C - New RatingAuthor: Error_YuanFirst Blood: ksun48 at 00:05:34 Solution 1 (with hints)Hint 1Binary search. Hint 2Do something backward. SolutionFirst, do binary search on the answer. Suppose we're checking whether the answer can be â‰¥ğ‘˜â‰¥k now.Let ğ‘“ğ‘–fi be the current rating after participating in the 11-st to the ğ‘–i-th contest (without skipping).Let ğ‘”ğ‘–gi be the minimum rating before the ğ‘–i-th contest to make sure that the final rating is â‰¥ğ‘˜â‰¥k (without skipping).ğ‘“ğ‘–fi-s can be calculated easily by simulating the process in the statement. For ğ‘”ğ‘–gi-s, it can be shown that  ğ‘”ğ‘–={ğ‘”ğ‘–+1âˆ’1,ğ‘”ğ‘–+1+1,ğ‘ğ‘–â‰¥ğ‘”ğ‘–+1ğ‘ğ‘–<ğ‘”ğ‘–+1gi={gi+1âˆ’1,aiâ‰¥gi+1gi+1+1,ai<gi+1where ğ‘”ğ‘›+1=ğ‘˜gn+1=k.Then, we should check if there exists an interval [ğ‘™,ğ‘Ÿ][l,r] (1â‰¤ğ‘™â‰¤ğ‘Ÿâ‰¤ğ‘›1â‰¤lâ‰¤râ‰¤n), such that ğ‘“ğ‘™âˆ’1â‰¥ğ‘”ğ‘Ÿ+1flâˆ’1â‰¥gr+1. If so, we can choose to skip [ğ‘™,ğ‘Ÿ][l,r] and get a rating of â‰¥ğ‘˜â‰¥k. Otherwise, it is impossible to make the rating â‰¥ğ‘˜â‰¥k.We can enumerate on ğ‘Ÿr and use a prefix max to check whether valid ğ‘™l exists.Time complexity: îˆ»(ğ‘›logğ‘›)O(nlogâ¡n) per test case. Solution 2 (with hints)Hint 1Consider DP. Hint 2There are only three possible states for each contest: before, in, or after the skipped interval. SolutionConsider ğ‘‘ğ‘ğ‘–,0/1/2=dpi,0/1/2= the maximum rating after the ğ‘–i-th contest, where the ğ‘–i-th contest is before/in/after the skipped interval.Let ğ‘“(ğ‘,ğ‘¥)=f(a,x)= the result rating when current rating is ğ‘a and the performance rating is ğ‘¥x, then â§â©â¨âªâªğ‘‘ğ‘ğ‘–,0=ğ‘“(ğ‘‘ğ‘ğ‘–âˆ’1,0,ğ‘ğ‘–),ğ‘‘ğ‘ğ‘–,1=max(ğ‘‘ğ‘ğ‘–âˆ’1,1,ğ‘‘ğ‘ğ‘–âˆ’1,0),ğ‘‘ğ‘ğ‘–,2=max(ğ‘“(ğ‘‘ğ‘ğ‘–âˆ’1,1,ğ‘ğ‘–),ğ‘“(ğ‘‘ğ‘ğ‘–âˆ’1,2,ğ‘ğ‘–)).{dpi,0=f(dpiâˆ’1,0,ai),dpi,1=max(dpiâˆ’1,1,dpiâˆ’1,0),dpi,2=max(f(dpiâˆ’1,1,ai),f(dpiâˆ’1,2,ai)).And the final answer is max(ğ‘‘ğ‘ğ‘›,1,ğ‘‘ğ‘ğ‘›,2)max(dpn,1,dpn,2).Time complexity: îˆ»(ğ‘›)O(n) per test case. Code (Solution 1, C++)#include <bits/stdc++.h>
#define all(s) s.begin(), s.end()
using namespace std;
using ll = long long;
using ull = unsigned long long;

const int _N = 1e5 + 5;

int T;

void solve() {
	int n; cin >> n;
	vector<int> a(n + 1);
	for (int i = 1; i <= n; i++) cin >> a[i];
	vector<int> pre(n + 1);
	int curf = 0;
	for (int i = 1; i <= n; i++) {
		if (curf < a[i]) curf++;
		else if (curf > a[i]) curf--;
		pre[i] = max(pre[i - 1], curf);
	}
	auto check = [&](int k) {
		int curg = k;
		for (int i = n; i >= 1; i--) {
			if (pre[i - 1] >= curg) return true;
			if (a[i] < curg) curg++;
			else curg--;
		}
		return false;
	};
	int L = 0, R = n + 1;
	while (L < R) {
		int mid = (L + R + 1) >> 1;
		if (check(mid)) L = mid;
		else R = mid - 1;
	}
	cout << L << '\n';
	return;
}

int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> T;
	while (T--) {
		solve();
	}
} Code (Solution 2, Python 3)for _ in range(int(input())):
    n = int(input())
    
    def f(a, x):
        return a + (a < x) - (a > x)
    
    dp = [0, -n, -n]
    for x in map(int, input().split()):
        dp[2] = max(f(dp[1], x), f(dp[2], x))
        dp[1] = max(dp[1], dp[0])
        dp[0] = f(dp[0], x)

    print(max(dp[1], dp[2])) Rate the Problem Amazing problem: 

    


365



 Good problem: 

    


89



 Average problem: 

    


20



 Bad problem: 

    


34



 Didn't solve: 

    


59



 2029D - Cool GraphAuthor: Error_YuanFirst Blood: ksun48 at 00:13:24There are many different approaches to this problem. Only the easiest one (at least I think so) is shared here. Hint 1Try to make the graph into a forest first. Hint 2(ğ‘‘ğ‘’ğ‘”ğ‘–â‰¤1degiâ‰¤1 for every ğ‘–i) âŸ¹âŸ¹ (The graph is a forest). SolutionLet ğ‘‘ğ‘–di be the degree of vertex ğ‘–i. First, we keep doing the following until it is impossible:  Choose a vertex ğ‘¢u with ğ‘‘ğ‘¢â‰¥2duâ‰¥2, then find any two vertices ğ‘£,ğ‘¤v,w adjacent to ğ‘¢u. Perform the operation on (ğ‘¢,ğ‘£,ğ‘¤)(u,v,w). Since each operation decreases the number of edges by at least 11, at most ğ‘šm operations will be performed. After these operations, ğ‘‘ğ‘–â‰¤1diâ‰¤1 holds for every ğ‘–i. Thus, the resulting graph consists only of components with size â‰¤2â‰¤2.If there are no edges, the graph is already cool, and we don't need to do any more operations.Otherwise, let's pick an arbitrary edge (ğ‘¢,ğ‘£)(u,v) as the base of the final tree, and then merge everything else to it.For a component with size =1=1 (i.e. it is a single vertex ğ‘¤w), perform the operation on (ğ‘¢,ğ‘£,ğ‘¤)(u,v,w), and set (ğ‘¢,ğ‘£)â†(ğ‘¢,ğ‘¤)(u,v)â†(u,w).For a component with size =2=2 (i.e. it is an edge connecting ğ‘a and ğ‘b), perform the operation on (ğ‘¢,ğ‘,ğ‘)(u,a,b).It is clear that the graph is transformed into a tree now.The total number of operations won't exceed ğ‘›+ğ‘šâ‰¤2â‹…max(ğ‘›,ğ‘š)n+mâ‰¤2â‹…max(n,m).In the author's solution, we used some data structures to maintain the edges, thus, the time complexity is îˆ»(ğ‘›+ğ‘šlogğ‘š)O(n+mlogâ¡m) per test case. Code (C++)#include <bits/stdc++.h>
using namespace std;
#ifdef DEBUG
#include "debug.hpp"
#else
#define debug(...) (void)0
#endif

using i64 = int64_t;
constexpr bool test = false;

int main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  int t;
  cin >> t;
  for (int ti = 0; ti < t; ti += 1) {
    int n, m;
    cin >> n >> m;
    vector<set<int>> adj(n + 1);
    for (int i = 0, u, v; i < m; i += 1) {
      cin >> u >> v;
      adj[u].insert(v);
      adj[v].insert(u);
    }
    vector<tuple<int, int, int>> ans;
    for (int i = 1; i <= n; i += 1) {
      while (adj[i].size() >= 2) {
        int u = *adj[i].begin();
        adj[i].erase(adj[i].begin());
        int v = *adj[i].begin();
        adj[i].erase(adj[i].begin());
        adj[u].erase(i);
        adj[v].erase(i);
        ans.emplace_back(i, u, v);
        if (adj[u].contains(v)) {
          adj[u].erase(v);
          adj[v].erase(u);
        } else {
          adj[u].insert(v);
          adj[v].insert(u);
        }
      }
    }
    vector<int> s;
    vector<pair<int, int>> p;
    for (int i = 1; i <= n; i += 1) {
      if (adj[i].size() == 0) {
        s.push_back(i);
      } else if (*adj[i].begin() > i) {
        p.emplace_back(i, *adj[i].begin());
      }
    }
    if (not p.empty()) {
      auto [x, y] = p.back();
      p.pop_back();
      for (int u : s) {
        ans.emplace_back(x, y, u);
        tie(x, y) = pair(x, u);
      }
      for (auto [u, v] : p) {
        ans.emplace_back(y, u, v);
      }
    }
    println("{}", ans.size());
    for (auto [x, y, z] : ans) println("{} {} {}", x, y, z);
  }
} Rate the Problem Amazing problem: 

    


211



 Good problem: 

    


50



 Average problem: 

    


15



 Bad problem: 

    


29



 Didn't solve: 

    


24



 2029E - Common GeneratorAuthor: Error_Yuan, wyrqwqFirst Blood: ksun48 at 00:23:50 Hint 122 is powerful. Hint 2Consider primes. Hint 3How did you prove that 22 can generate every integer except odd primes? Can you generalize it? SolutionIn this problem, we do not take the integer 11 into consideration.Claim 1. 22 can generate every integer except odd primes.Proof. For a certain non-prime ğ‘¥x, let mind(ğ‘¥)mindâ¡(x) be the minimum divisor of ğ‘¥x. Then ğ‘¥âˆ’mind(ğ‘¥)xâˆ’mindâ¡(x) must be an even number, which is â‰¥2â‰¥2. So ğ‘¥âˆ’mind(ğ‘¥)xâˆ’mindâ¡(x) can be generated by 22, and ğ‘¥x can be generated by ğ‘¥âˆ’mind(ğ‘¥)xâˆ’mindâ¡(x). Thus, 22 is a generator of ğ‘¥x.Claim 2. Primes can only be generated by themselves.According to the above two claims, we can first check if there exist primes in the array ğ‘a. If not, then 22 is a common generator. Otherwise, let the prime be ğ‘p, the only possible generator should be ğ‘p itself. So we only need to check whether ğ‘p is a generator of the rest integers.For an even integer ğ‘¥x, it is easy to see that, ğ‘p is a generator of ğ‘¥x if and only if ğ‘¥â‰¥2â‹…ğ‘xâ‰¥2â‹…p. Claim 3. For a prime ğ‘p and an odd integer ğ‘¥x, ğ‘p is a generator of ğ‘¥x if and only if ğ‘¥âˆ’mind(ğ‘¥)â‰¥2â‹…ğ‘xâˆ’mindâ¡(x)â‰¥2â‹…p.Proof. First, ğ‘¥âˆ’mind(ğ‘¥)xâˆ’mindâ¡(x) is the largest integer other than ğ‘¥x itself that can generate ğ‘¥x. Moreover, only even numbers â‰¥2â‹…ğ‘â‰¥2â‹…p can be generated by ğ‘p (ğ‘¥âˆ’mind(ğ‘¥)xâˆ’mindâ¡(x) is even). That ends the proof.Thus, we have found a good way to check if a certain number can be generated from ğ‘p. We can use the linear sieve to pre-calculate all the mind(ğ‘–)mindâ¡(i)-s.Time complexity: îˆ»(âˆ‘ğ‘›+ğ‘‰)O(âˆ‘n+V), where ğ‘‰=maxğ‘ğ‘–V=maxai.Some other solutions with worse time complexity can also pass, such as îˆ»(ğ‘‰logğ‘‰)O(Vlogâ¡V) and îˆ»(ğ‘¡ğ‘‰â€¾â€¾âˆš)O(tV). Code (C++)#include <bits/stdc++.h>
#define all(s) s.begin(), s.end()
using namespace std;
using ll = long long;
using ull = unsigned long long;

const int _N = 4e5 + 5;

int vis[_N], pr[_N], cnt = 0;

void init(int n) {
	vis[1] = 1;
	for (int i = 2; i <= n; i++) {
		if (!vis[i]) {
			pr[++cnt] = i;
		}
		for (int j = 1; j <= cnt && i * pr[j] <= n; j++) {
			vis[i * pr[j]] = pr[j];
			if (i % pr[j] == 0) continue;
		}
	}
}

int T;

void solve() {
	int n; cin >> n;
	vector<int> a(n + 1);
	for (int i = 1; i <= n; i++) cin >> a[i];
	int p = 0;
	for (int i = 1; i <= n; i++) {
		if (!vis[a[i]]) p = a[i];
	}
	if (!p) {
		cout << 2 << '\n';
		return;
	}
	for (int i = 1; i <= n; i++) {
		if (a[i] == p) continue;
		if (vis[a[i]] == 0) {
			cout << -1 << '\n';
			return;
		}
		if (a[i] & 1) {
			if (a[i] - vis[a[i]] < 2 * p) {
				cout << -1 << '\n';
				return;
			}
		} else {
			if (a[i] < 2 * p) {
				cout << -1 << '\n';
				return;
			}
		}
	}
	cout << p << '\n';
	return;
}

int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	init(400000);
	cin >> T;
	while (T--) {
		solve();
	}
} Rate the Problem Amazing problem: 

    


136



 Good problem: 

    


70



 Average problem: 

    


18



 Bad problem: 

    


22



 Didn't solve: 

    


16



 2029F - Palindrome EverywhereAuthor: sszcdjrFirst Blood: taeyeon_ss at 00:16:50 Hint 1If there are both consecutive ğšR-s and ğ™±B-s, does the condition hold for all (ğ‘–,ğ‘—)(i,j)? Why?  Hint 2Suppose that there are only consecutive ğšR-s, check the parity of the number of ğšR-s in each consecutive segment of ğšR-s. Hint 3If for each consecutive segment of ğšR-s, the parity of the number of ğšR-s is odd, does the condition hold for all (ğ‘–,ğ‘—)(i,j)? Why?  Hint 4If for at least two of the consecutive segments of ğšR-s, the parity of the number of ğšR-s is even, does the condition hold for all (ğ‘–,ğ‘—)(i,j)? Why?  Hint 5Is this the necessary and sufficient condition? Why? Hint 6Don't forget some trivial cases like ğšğšğš...ğšğ™±RRR...RB and ğšğšğš...ğšRRR...R. SolutionFor each ğ‘˜>ğ‘›k>n or ğ‘˜â‰¤0kâ‰¤0, let ğ‘ğ‘˜ck be ğ‘ğ‘˜modğ‘›ckmodn.Lemma 1: If there are both consecutive ğšR-s and ğ™±B-s, the answer is NO.Proof 1: Suppose that ğ‘ğ‘–âˆ’1=ğ‘ğ‘–=ğšciâˆ’1=ci=R and ğ‘ğ‘—âˆ’1=ğ‘ğ‘—=ğ™±cjâˆ’1=cj=B, it's obvious that there doesn't exist a palindrome route between ğ‘–i and ğ‘—j.Imagine there are two persons on vertex ğ‘–i and ğ‘—j. They want to meet each other (they are on the same vertex or adjacent vertex) and can only travel through an edge of the same color.Lemma 2: Suppose that there are only consecutive ğšR-s, if for each consecutive segment of ğšR-s, the parity of the number of ğšR-s is odd, the answer is NO.Proof 2: Suppose that ğ‘ğ‘–=ğ‘ğ‘—=ğ™±ci=cj=B, ğ‘–â‰¢ğ‘—(modğ‘›)iâ‰¢j(modn) and ğ‘ğ‘–+1=ğ‘ğ‘–+2=â‹¯=ğ‘ğ‘—âˆ’1=ğšci+1=ci+2=â‹¯=cjâˆ’1=R. The two persons on ğ‘–i and ğ‘—j have to "cross" ğ™±B simultaneously. As for each consecutive segment of ğšR-s, the parity of the number of ğšR-s is odd, they can only get to the same side of their current consecutive segment of ğšR-s. After "crossing" ğ™±B, they will still be on different consecutive segments of ğšR-s separated by exactly one ğ™±B and can only get to the same side. Thus, they will never meet.Lemma 3: Suppose that there are only consecutive ğšR-s, if, for at least two of the consecutive segments of ğšR-s, the parity of the number of ğšR-s is even, the answer is NO.Proof 3: Suppose that ğ‘ğ‘–=ğ‘ğ‘—=ğ™±ci=cj=B, ğ‘–â‰¢ğ‘—(modğ‘›)iâ‰¢j(modn) and vertex ğ‘–i and ğ‘—j are both in a consecutive segment of ğšR-s with even number of ğšR-s. Let the starting point of two persons be ğ‘–i and ğ‘—âˆ’1jâˆ’1 and they won't be able to "cross" and ğ™±B. Thus, they will never meet.The only case left is that there is exactly one consecutive segment of ğšR-s with an even number of ğšR-s.Lemma 4: Suppose that there are only consecutive ğšR-s, if, for exactly one of the consecutive segments of ğšR-s, the parity of the number of ğšR-s is even, the answer is YES.Proof 4: Let the starting point of the two persons be ğ‘–,ğ‘—i,j. Consider the following cases:Case 1: If vertex ğ‘–i and ğ‘—j are in the same consecutive segment of ğšR-s, the two persons can meet each other by traveling through the ğšR-s between them.Case 2: If vertex ğ‘–i and ğ‘—j are in the different consecutive segment of ğšR-s and there are odd numbers of ğšR-s in both segments, the two person may cross ğ™±B-s in the way talked about in Proof 2. However, when one of them reaches a consecutive segment with an even number of ğšR-s, the only thing they can do is let the one in an even segment cross the whole segment and "cross" the next ğ™±B in the front, while letting the other one traveling back and forth and "cross" the ğ™±B he just "crossed". Thus, unlike the situation in Proof 2, we successfully changed the side they can both get to and thus they will be able to meet each other as they are traveling toward each other and there are only odd segments between them.Case 3: If vertex ğ‘–i and ğ‘—j are in the different consecutive segment of ğšR-s and there are an odd number of ğšR-s in exactly one of the segments, we can let both of them be in one side of there segments and change the situation to the one we've discussed about in Case 2 (when one of them reached a consecutive segment with even number of ğšR-s).As a result, the answer is YES if:  At least ğ‘›âˆ’1nâˆ’1 of ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›c1,c2,â€¦,cn are the same (Hint 6), or Suppose that there are only consecutive ğšR-s, there's exactly one of the consecutive segments of ğšR-s such that the parity of the number of ğšR-s is even. And we can judge them in îˆ»(ğ‘›)O(n) time complexity. Code (C++)#include <bits/stdc++.h>
using namespace std;
void solve(){
	int n; cin>>n;
	string s; cin>>s;
	int visr=0,visb=0,ok=0; 
	for(int i=0;i<n;i++){
		if(s[i]==s[(i+1)%n]){
			if(s[i]=='R') visr=1;
			else visb=1;
			ok++;
		}
	}
	if(visr&visb){
		cout<<"NO\n";
		return ;
	}
	if(ok==n){
		cout<<"YES\n";
		return ;
	}
	if(visb) for(int i=0;i<n;i++) s[i]='R'+'B'-s[i];
	int st=0;
	for(int i=0;i<n;i++) if(s[i]=='B') st=(i+1)%n;
	vector<int> vc;
	int ntot=0,cnt=0;
	for(int i=0,j=st;i<n;i++,j=(j+1)%n){
		if(s[j]=='B') vc.push_back(ntot),cnt+=(ntot&1)^1,ntot=0;
		else ntot++;
	}
	if(vc.size()==1||cnt==1){
		cout<<"YES\n";
		return ;
	}
	cout<<"NO\n";
	return ;
}
signed main(){
	int t; cin>>t;
	while(t--) solve();
	return 0;
} Bonus 1Count the number of strings of length ğ‘›n satisfying the condition. Bonus 2Solve the problem for ğ‘ğ‘–âˆˆ{ğ™°,ğ™±,â€¦,ğš‰}ciâˆˆ{A,B,â€¦,Z}, and solve the counting version. Rate the Problem Amazing problem: 

    


29



 Good problem: 

    


41



 Average problem: 

    


11



 Bad problem: 

    


46



 Didn't solve: 

    


21



 2029G - Balanced ProblemAuthor: wyrqwq, Error_YuanFirst Blood: taeyeon_ss at 00:56:22This problem has two approaches. The first one is the authors' solution, and the second one was found during testing. Solution 1 (with hints)Hint 1The array ğ‘a is constructed with the operations. How can we use this property? Hint 2If we want to make all ğ‘ğ‘–=ğ‘¥ai=x, what is the minimum value of ğ‘¥x? Use the property mentioned in Hint 1. Hint 3(For the subproblem in Hint 2), try to find an algorithm related to the positions of ğ™»/ğšL/R-s directly. Hint 4(For the subproblem in Hint 2), the conclusion is that, the minimum ğ‘¥x equals # ofÂ ğ™»-s+# ofÂ ğš-sâˆ’# of adjacentÂ ğ™»ğš-s# ofÂ L-s+# ofÂ R-sâˆ’# of adjacentÂ LR-s. Think why. Hint 5Go for DP. SolutionRead the hints first.Then, note that there are only îˆ»(ğ‘‰)O(V) useful positions: If (after the initial operations) ğ‘ğ‘–>ğ‘‰ai>V or ğ‘ğ‘–=ğ‘ğ‘–âˆ’1ai=aiâˆ’1, we can simply ignore ğ‘ğ‘–ai, or merge ğ‘ğ‘–ci into ğ‘ğ‘–âˆ’1ciâˆ’1.Now let ğ‘‘ğ‘(ğ‘–,ğ‘ )dp(i,s) denote the answer when we consider the prefix of length ğ‘–i, and we have "saved" ğ‘ s pairs of ğ™»ğšLR.Then, ğ‘‘ğ‘(ğ‘–,ğ‘ )=maxğ‘—<ğ‘–ğ‘‘ğ‘(ğ‘—,ğ‘ âˆ’|cntL(ğ‘—,ğ‘–âˆ’1)âˆ’cntR(ğ‘—+1,ğ‘–)|)+ğ‘ğ‘–dp(i,s)=maxj<idp(j,sâˆ’|cntL(j,iâˆ’1)âˆ’cntR(j+1,i)|)+ciWrite cntLcntL and cntRcntR as prefix sums: ğ‘‘ğ‘(ğ‘–,ğ‘ )=maxğ‘—<ğ‘–ğ‘‘ğ‘(ğ‘—,ğ‘ âˆ’|preL(ğ‘–âˆ’1)âˆ’preR(ğ‘–)+preR(ğ‘—)âˆ’preL(ğ‘—âˆ’1)|)+ğ‘ğ‘–dp(i,s)=maxj<idp(j,sâˆ’|preL(iâˆ’1)âˆ’preR(i)+preR(j)âˆ’preL(jâˆ’1)|)+ciDo casework on the sign of the things inside the absabs, and you can maintain both cases with 1D Fenwick trees.Thus, you solved the problem in îˆ»(ğ‘‰2logğ‘‰)O(V2logâ¡V). Solution 2 (with hints)Hint 1Solve the problem for a single ğ‘£v first. Hint 2Don't think too much, just go straight for a DP solution. Hint 3Does your time complexity in DP contain ğ‘›n or ğ‘šm? In fact, both ğ‘›n and ğ‘šm are useless. There are only îˆ»(ğ‘‰)O(V) useful positions. Hint 4Use some data structures to optimize your DP. Even îˆ»(ğ‘£2log2ğ‘£)O(v2log2â¡v) is acceptable. Hint 5Here is the final step: take a look at your DP carefully. Can you change the definition of states a little, so that it can get the answer for each 1â‰¤ğ‘£â‰¤ğ‘‰1â‰¤vâ‰¤V? SolutionFirst, note that there are only îˆ»(ğ‘‰)O(V) useful positions: If (after the initial operations) ğ‘ğ‘–>ğ‘‰ai>V or ğ‘ğ‘–=ğ‘ğ‘–âˆ’1ai=aiâˆ’1, we can simply ignore ğ‘ğ‘–ai, or merge ğ‘ğ‘–ci into ğ‘ğ‘–âˆ’1ciâˆ’1.Now, let's solve the problem for a single ğ‘£v.Denote ğ‘‘ğ‘(ğ‘–,ğ‘—,ğ‘˜)dp(i,j,k) as the maximum answer when considering the prefix of length ğ‘–i, and there are ğ‘—j prefix additions covering ğ‘–i, ğ‘˜k suffix additions covering ğ‘–i.Enumerate on ğ‘–i, and it is easy to show that the state changes if and only if ğ‘—+ğ‘˜+ğ‘ğ‘–=ğ‘£j+k+ai=v, and ğ‘‘ğ‘(ğ‘–,ğ‘—,ğ‘˜)=maxğ‘â‰¤ğ‘—,ğ‘â‰¥ğ‘˜ğ‘‘ğ‘(ğ‘–âˆ’1,ğ‘,ğ‘)+ğ‘ğ‘–dp(i,j,k)=maxpâ‰¤j,qâ‰¥kdp(iâˆ’1,p,q)+ciYou can use a 2D Fenwick tree to get the 2D prefix max. Thus, you solved the single ğ‘£v case in îˆ»(ğ‘£2log2ğ‘£)O(v2log2â¡v).In fact, we can process the DP in îˆ»(ğ‘£2logğ‘£)O(v2logâ¡v) by further optimization:  ğ‘‘ğ‘(ğ‘–,ğ‘—,ğ‘˜)=maxğ‘â‰¤ğ‘–âˆ’1,ğ‘â‰¥ğ‘—,ğ‘£âˆ’ğ‘ğ‘âˆ’ğ‘â‰¤ğ‘˜ğ‘‘ğ‘(ğ‘,ğ‘,ğ‘£âˆ’ğ‘ğ‘âˆ’ğ‘)+ğ‘ğ‘–dp(i,j,k)=maxpâ‰¤iâˆ’1,qâ‰¥j,vâˆ’apâˆ’qâ‰¤kdp(p,q,vâˆ’apâˆ’q)+ciThis only requires ğ‘ğ‘+ğ‘â‰¥ğ‘ğ‘–+ğ‘—ap+qâ‰¥ai+j when ğ‘ğ‘â‰¤ğ‘ğ‘–apâ‰¤ai, and ğ‘â‰¤ğ‘—qâ‰¤j when ğ‘ğ‘â‰¥ğ‘ğ‘–apâ‰¥ai. So you can use 1D Fenwick trees to process the dp in îˆ»(ğ‘£2logğ‘£)O(v2logâ¡v).Now, let's go for the whole solution.Let's modify the DP state a bit: now ğ‘‘ğ‘(ğ‘–,ğ‘—,ğ‘˜)dp(i,j,k) is the state when using ğ‘£âˆ’ğ‘˜vâˆ’k suffix operations (note that ğ‘£v is not a constant here). The transformation is similar.Then the answer for ğ‘£=ğ‘–v=i will be maxğ‘‘ğ‘(âˆ—,âˆ—,ğ‘–)maxdp(âˆ—,âˆ—,i). Code (Solution 1, C++)#include <bits/stdc++.h>
#define all(s) s.begin(), s.end()
using namespace std;
using ll = long long;
using ull = unsigned long long;
using ld = double;

const int _N = 4105;
const ld inf = 1e15;

int T;

struct fenwick {
	ll c[_N]; int N;
	int lowbit(int x) { return x & (-x); }
	void init(int n) {
		N = n;
		for (int i = 1; i <= N; i++) c[i] = -1e18;
	}
	void update(int x, ll v) {
		// assert(x != 0);
		while (x < N) {
			c[x] = max(c[x], v);
			x += lowbit(x);
		}
	}
	ll getmx(int x) {
		// assert(x != 0);
		ll res = -1e18;
		while (x > 0) {
			res = max(res, c[x]);
			x -= lowbit(x);
		}
		return res;
	}
} pre[4105], suf[4105];

void solve() {
	int n, o, m, k; cin >> n >> o >> m;
	k = 0;
	vector<ll> a(n + 3), c(n + 3), d(n + 3), L(n + 3), R(n + 3), L2(n + 3), R2(n + 3);
	for (int i = 1; i <= n; i++) cin >> c[i];
	for (int i = 1; i <= o; i++) {
		char op; int x; cin >> op >> x;
		if (op == 'L') L[x]++;
		else R[x]++;
	}
	vector<int> tL(n + 3), tR(n + 3);
	for (int i = 1; i <= n; i++) tR[i] = tR[i - 1] + R[i];
	for (int i = n; i >= 1; i--) tL[i] = tL[i + 1] + L[i];
	int q = 0, curL = 0, curR = 0;
	for (int i = 1; i <= n; i++) {
		a[i] = tL[i] + tR[i];
		if (a[i] <= m + k) {
		    if (a[i] == a[i - 1] && L[i] == 0 && R[i] == 0) {
		        if (q == 0) q++;
		        d[q] += c[i];
		        continue;
		    }
			q++;
			L2[q] += L[i];
			R2[q] += R[i] + curR;
			L2[q - 1] += curL;
			d[q] += c[i];
			curL = curR = 0;
		} else {
			curL += L[i];
			curR += R[i];
		}
	}
	L2[0] = 0; L2[q] += curL;
	for (int i = 1; i <= q; i++) L2[i] += L2[i - 1], R2[i] += R2[i - 1];
    m += k;
    vector<ll> dp(2 * m + 2, -1e18);
	for (int i = 0; i <= 2 * m; i++) {
		pre[i].init(2 * m + 2);
		suf[i].init(2 * m + 2);
	}
	vector<ll> ans(m + 1);
	for (int i = 1; i <= q; i++) {
        dp.resize(2 * m + 2, -1e18);
		dp[L2[i - 1]] = d[i];
		for (int s = 0; s <= m; s++) {
			ll res1 = pre[s - L2[i - 1] + m].getmx(R2[i] - L2[i - 1] + m + 1);
			ll res2 = suf[s - R2[i] + m].getmx(m + 1 - R2[i] + L2[i - 1]);
			dp[s] = max({ dp[s], res1 + d[i], res2 + d[i] });
			if (L2[q] + R2[i] - s >= 0 && L2[q] + R2[i] - s <= m) ans[L2[q] + R2[i] - s] = max(ans[L2[q] + R2[i] - s], dp[s]);
		}
		for (int s = 0; s <= m; s++) {
			if (dp[s] <= -1e12) continue;
			pre[s - L2[i - 1] + m].update(R2[i] - L2[i - 1] + m + 1, dp[s]);
			suf[s - R2[i] + m].update(m + 1 - R2[i] + L2[i - 1], dp[s]);
		}
	}
	for (int i = 1; i <= m; i++) {
		ans[i] = max(ans[i - 1], ans[i]);
		cout << ans[i] << " \n"[i == m];
	}
	return;
}

int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> T;
	while (T--) {
		solve();
	}
} Code (Solution 2, C++)#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pb push_back
#define pii pair<int, int>
#define all(a) a.begin(), a.end()
const int mod = 1e9 + 7, N = 5005;

void solve() {
    int n, m, V;
    cin >> n >> m >> V;
    vector <int> c(n);
    for (int i = 0; i < n; ++i) {
        cin >> c[i];
    }
    vector <int> pre(n + 1);
    for (int i = 0; i < m; ++i) {
        char x; int v; cin >> x >> v, --v;
        if (x == 'L') {
            pre[0]++, pre[v + 1]--;
        } else {
            pre[v]++;
        }
    }
    for (int i = 0; i < n; ++i) {
        pre[i + 1] += pre[i];
    }
    vector <pair <ll, int>> vec;
    for (int i = 0, j = 0; i < n; i = j) {
        ll tot = 0;
        while (j < n && pre[i] == pre[j]) {
            tot += c[j], j++;
        }
        if (pre[i] <= V) {
            vec.emplace_back(tot, pre[i]);
        }
    }

    vector bit(V + 5, vector <ll>(V + 5, -1ll << 60));
    auto upd = [&](int x, int y, ll v) {
        for (int i = x + 1; i < V + 5; i += i & (-i)) {
            for (int j = y + 1; j < V + 5; j += j & (-j)) {
                bit[i][j] = max(bit[i][j], v);
            }
        }
    };
    auto query = [&](int x, int y) {
        ll ans = -1ll << 60;
        for (int i = x + 1; i > 0; i -= i & (-i)) {
            for (int j = y + 1; j > 0; j -= j & (-j)) {
                ans = max(ans, bit[i][j]);
            }
        }
        return ans;
    };

    upd(0, 0, 0);
    vector <ll> tmp(V + 1);
    for (auto [val, diff] : vec) {
        for (int i = 0; i + diff <= V; ++i) {
            tmp[i] = query(i, i + diff);
        }
        for (int i = 0; i + diff <= V; ++i) {
            upd(i, i + diff, tmp[i] + val);
        }
    }

    for (int i = 1; i <= V; ++i) {
        cout << query(i, i) << " \n"[i == V];
    }
}

int main() {
    ios::sync_with_stdio(false), cin.tie(0);
    int t;
    cin >> t;
    while (t--) {
        solve();
    }
} Rate the Problem Amazing problem: 

    


19



 Good problem: 

    


8



 Average problem: 

    


3



 Bad problem: 

    


2



 Didn't solve: 

    


22



  BonusSolve the problem in îˆ»(ğ‘‰2)O(V2).2029H - Message SpreadAuthor: sszcdjrFirst Blood: Benq at 02:04:40 (though unintended brute force), jiangly at 02:55:12 (intended, orz!) Hint 1It's hard to calculate the expected number. Try to change it to the probability. Hint 2Consider a îˆ»(3ğ‘›)O(3n) dp first. Hint 3Use inclusion and exclusion. Hint 4Write out the transformation. Try to optimize it. SolutionLet ğ‘‘ğ‘ğ‘†dpS be the probability such that exactly the points in ğ‘†S have the message.The answer is âˆ‘ğ‘‘ğ‘ğ‘†â‹…ğ‘¡ğ‘Ÿğ‘†âˆ‘dpSâ‹…trS, where ğ‘¡ğ‘Ÿğ‘†trS is the expected number of days before at least one vertex out of ğ‘†S to have the message (counting from the day that exactly the points in ğ‘†S have the message).For transformation, enumerate ğ‘†,ğ‘‡S,T such that ğ‘†âˆ©ğ‘‡=âˆ…Sâˆ©T=âˆ…. Transfer ğ‘‘ğ‘ğ‘†dpS to ğ‘‘ğ‘ğ‘†âˆªğ‘‡dpSâˆªT. It's easy to precalculate the coefficient, and the time complexity differs from îˆ»(3ğ‘›)O(3n), îˆ»(ğ‘›â‹…3ğ‘›)O(nâ‹…3n) to îˆ»(ğ‘›2â‹…3ğ‘›)O(n2â‹…3n), according to the implementation.The transformation is hard to optimize. Enumerate ğ‘‡T and calculate the probability such that vertices in ğ‘†S is only connected with vertices in ğ‘‡T, which means that the real status ğ‘…R satisfies ğ‘†âŠ†ğ‘…âŠ†(ğ‘†âˆªğ‘‡)SâŠ†RâŠ†(SâˆªT). Use inclusion and exclusion to calculate the real probability.List out the coefficient: âˆğ‘’âˆˆ{1,2,3,â€¦,ğ‘›}(1âˆ’ğ‘¤ğ‘’)â‹…âˆğ‘’âˆˆ(ğ‘†âˆªğ‘‡)11âˆ’ğ‘¤ğ‘’â‹…âˆğ‘’âˆˆ{1,2,â€¦,ğ‘›}âˆ–ğ‘†11âˆ’ğ‘¤ğ‘’â‹…âˆğ‘’âˆˆğ‘‡(1âˆ’ğ‘¤ğ‘’)1âˆ’âˆğ‘’âˆˆ{1,2,3,â€¦,ğ‘›}(1âˆ’ğ‘¤ğ‘’)â‹…âˆğ‘’âˆˆğ‘†11âˆ’ğ‘¤ğ‘’â‹…âˆğ‘’âˆˆ{1,2,3,â€¦,ğ‘›}âˆ–ğ‘†11âˆ’ğ‘¤ğ‘’âˆeâˆˆ{1,2,3,â€¦,n}(1âˆ’we)â‹…âˆeâˆˆ(SâˆªT)11âˆ’weâ‹…âˆeâˆˆ{1,2,â€¦,n}âˆ–S11âˆ’weâ‹…âˆeâˆˆT(1âˆ’we)1âˆ’âˆeâˆˆ{1,2,3,â€¦,n}(1âˆ’we)â‹…âˆeâˆˆS11âˆ’weâ‹…âˆeâˆˆ{1,2,3,â€¦,n}âˆ–S11âˆ’we(Note that ğ‘¤ğ‘’we denotes the probability of the appearance of the edge ğ‘’e)We can express it as Constâ‹…ğ‘“ğ‘†âˆªğ‘‡â‹…ğ‘”ğ‘†â‹…â„ğ‘‡Constâ‹…fSâˆªTâ‹…gSâ‹…hT. Use a subset convolution to optimize it. The total time complexity is îˆ»(2ğ‘›â‹…ğ‘›2)O(2nâ‹…n2).It's easy to see that all ğ‘‘ğ‘ğ‘†â‰ 0dpSâ‰ 0 satisfies 1âˆˆğ‘†1âˆˆS, so the time complexity can be îˆ»(2ğ‘›âˆ’1â‹…ğ‘›2)O(2nâˆ’1â‹…n2) if well implemented. Code (C++)#include <bits/stdc++.h>
#define int long long 
using namespace std;
const int N=(1<<21),mod=998244353;
const int Lim=8e18;
inline void add(signed &i,int j){
	i+=j;
	if(i>=mod) i-=mod;
}
int qp(int a,int b){
	int ans=1;
	while(b){
		if(b&1) (ans*=a)%=mod;
		(a*=a)%=mod;
		b>>=1;
	}
	return ans;
}
int dp[N],f[N],g[N],h[N];
int s1[N],s2[N];
signed pre[22][N/2],t[22][N/2],pdp[N][22];
int p[N],q[N],totp,totq;
signed main(){
	int n,m; cin>>n>>m;
	int totprod=1;
	for(int i=0;i<(1<<n);i++) s1[i]=s2[i]=1;
	for(int i=1;i<=m;i++){
		int u,v,p,q; cin>>u>>v>>p>>q;
		int w=p*qp(q,mod-2)%mod;
		(s1[(1<<(u-1))+(1<<(v-1))]*=(mod+1-w))%=mod;
		(s2[(1<<(u-1))+(1<<(v-1))]*=qp(mod+1-w,mod-2))%=mod;
		(totprod*=(mod+1-w))%=mod;
	}
	for(int j=1;j<=n;j++) for(int i=0;i<(1<<n);i++) if((i>>(j-1))&1) (s1[i]*=s1[i^(1<<(j-1))])%=mod,(s2[i]*=s2[i^(1<<(j-1))])%=mod;
	for(int i=0;i<(1<<n);i++) f[i]=s2[i],g[i]=totprod*s2[((1<<n)-1)^i]%mod*qp(mod+1-totprod*s2[i]%mod*s2[((1<<n)-1)^i]%mod,mod-2)%mod,h[i]=s1[i];
	for(int i=1;i<(1<<n);i++) pre[__builtin_popcount(i)][i>>1]=h[i];
	dp[1]=1;
	for(int j=1;j<=n;j++){
		if(!((1>>(j-1))&1)) add(pdp[1|(1<<(j-1))][j],mod-(dp[1]*g[1]%mod*f[1]%mod));
	}
	t[0][0]=dp[1]*g[1]%mod;
	for(int k=1;k<=n;k++) for(int j=1;j<n;j++) for(int i=0;i<(1<<(n-1));i++) if((i>>(j-1))&1) add(pre[k][i],pre[k][i^(1<<(j-1))]);
	for(int j=1;j<n;j++) for(int i=0;i<(1<<(n-1));i++) if((i>>(j-1))&1) add(t[0][i],t[0][i^(1<<(j-1))]);
	for(int k=1;k<n;k++){
		totp=totq=0;
		for(int i=0;i<(1<<(n-1));i++) if(__builtin_popcount(i)<=k) p[++totp]=i; else q[++totq]=i;
		for(int l=1,i=p[l];l<=totp;l++,i=p[l]) for(int j=0;j<k;j++) add(t[k][i],1ll*t[j][i]*pre[k-j][i]%mod);
		for(int i=0;i<(1<<(n-1));i++) t[k][i]%=mod;
		for(int j=1;j<n;j++) for(int l=1,i=p[l];l<=totp;l++,i=p[l]) if((i>>(j-1))&1) add(t[k][i],mod-t[k][i^(1<<(j-1))]);
		for(int i=0;i<(1<<(n-1));i++){
			if(__builtin_popcount(i)==k){
				add(pdp[(i<<1)|1][0],t[k][i]*f[(i<<1)|1]%mod);
				int pre=0;
				for(int j=1;j<=n;j++){
					(pre+=pdp[(i<<1)|1][j-1])%=mod;
					if(!((((i<<1)|1)>>(j-1))&1)) add(pdp[(i<<1)|1|(1<<(j-1))][j],mod-pre);
				}
				(pre+=pdp[(i<<1)|1][n])%=mod;
				dp[(i<<1)|1]=pre;
				for(int j=1;j<=n;j++){
					if(!((((i<<1)|1)>>(j-1))&1)) add(pdp[(i<<1)|1|(1<<(j-1))][j],mod-(dp[(i<<1)|1]*g[(i<<1)|1]%mod*f[(i<<1)|1]%mod));
				}
				t[k][i]=pre*g[(i<<1)|1]%mod;
			}
			else t[k][i]=0;
		}
		for(int j=1;j<n;j++) for(int l=1,i=q[l];l<=totq;l++,i=q[l]) if((i>>(j-1))&1) add(t[k][i],t[k][i^(1<<(j-1))]);
	}
	int ans=0;
	for(int i=1;i<(1<<n)-1;i+=2) (ans+=dp[i]*qp(mod+1-totprod*s2[i]%mod*s2[((1<<n)-1)^i]%mod,mod-2)%mod)%=mod;
	cout<<ans;
	return 0;
} Rate the Problem Amazing problem: 

    


10



 Good problem: 

    


3



 Average problem: 

    


1



 Bad problem: 

    


3



 Didn't solve: 

    


19



 2029I - Variance ChallengeAuthor: Error_YuanFirst Blood: rainboy at 01:33:40 (intended, the only solve in contest, orz!) Hint 1The intended solution has nothing to do with dynamic programming. Hint 2This is the key observation of the problem. Suppose we have an array ğ‘b and a function ğ‘“(ğ‘¥)=âˆ‘(ğ‘ğ‘–âˆ’ğ‘¥)2f(x)=âˆ‘(biâˆ’x)2, then the minimum value of ğ‘“(ğ‘¥)f(x) is the variance of ğ‘b. Hint 3Using the observation mentioned in Hint 2, we can reduce the problem to minimizing âˆ‘(ğ‘ğ‘–âˆ’ğ‘¥)2âˆ‘(aiâˆ’x)2 for a given ğ‘¥x. There are only îˆ»(ğ‘›â‹…ğ‘š)O(nâ‹…m) possible ğ‘¥x-s. Hint 4The rest of the problem is somehow easy. Try flows, or just find a greedy algorithm! Hint 5If you are trying flows: the quadratic function is always convex.  SolutionKey Observation. Suppose we have an array ğ‘b and a function ğ‘“(ğ‘¥)=âˆ‘(ğ‘ğ‘–âˆ’ğ‘¥)2f(x)=âˆ‘(biâˆ’x)2, then the minimum value of ğ‘“(ğ‘¥)f(x) is the variance of ğ‘b.Proof. This is a quadratic function of ğ‘¥x, and the its symmetry axis is ğ‘¥=1ğ‘›âˆ‘ğ‘ğ‘–x=1nâˆ‘bi. So the minimum value is ğ‘“(1ğ‘›âˆ‘ğ‘ğ‘–)f(1nâˆ‘bi). That is exactly the definition of variance.Thus, we can enumerate all possible ğ‘¥x-s, and find the minimum âˆ‘(ğ‘ğ‘–âˆ’ğ‘¥)2âˆ‘(aiâˆ’x)2 after the operations, then take the minimum across them. That will give the correct answer to the original problem. Note that there are only îˆ»(ğ‘›â‹…ğ‘š)O(nâ‹…m) possible ğ‘¥x-s.More formally, let ğ‘˜ğ‘¥,ğ‘kx,c be the minimum value of âˆ‘(ğ‘ğ‘–âˆ’ğ‘¥)2âˆ‘(aiâˆ’x)2 after exactly ğ‘c operations. Then ansğ‘–=minany possibleÂ ğ‘¥ğ‘˜ğ‘¥,ğ‘–ansi=minany possibleÂ xkx,i.So we only need to solve the following (reduced) problem:  Given a (maybe non-integer) number ğ‘¥x. For each 1â‰¤ğ‘–â‰¤ğ‘š1â‰¤iâ‰¤m, find the minimum value of âˆ‘(ğ‘ğ‘–âˆ’ğ‘¥)2âˆ‘(aiâˆ’x)2 after exactly ğ‘–i operations. To solve this, we can use the MCMF model:  Set a source node ğ‘ s and a target node ğ‘¡t. For each 1â‰¤ğ‘–â‰¤ğ‘›1â‰¤iâ‰¤n, add an edge from ğ‘ s to ğ‘–i with cost 00. For each 1â‰¤ğ‘–â‰¤ğ‘›1â‰¤iâ‰¤n, add an edge from ğ‘–i to ğ‘¡t with cost 00. For each 1â‰¤ğ‘–<ğ‘›1â‰¤i<n, add an edge from ğ‘–i to ğ‘–+1i+1 with cost being a function cost(ğ‘“)=(ğ‘ğ‘–+ğ‘“âˆ’ğ‘¥)2âˆ’(ğ‘ğ‘–âˆ’ğ‘¥)2cost(f)=(ai+fâˆ’x)2âˆ’(aiâˆ’x)2, where ğ‘“f is the flow on this edge. Note that the costcost function is convex, so this model is correct, as you can split an edge into some edges with cost of cost(1)cost(1), cost(2)âˆ’cost(1)cost(2)âˆ’cost(1), cost(3)âˆ’cost(2)cost(3)âˆ’cost(2), and so on. Take a look at the model again. We don't need to run MCMF. We can see that it is just a process of regret greedy. So you only need to find the LIS (Largest Interval Sum :) ) for each operation.Thus, we solved the reduced problem in îˆ»(nâ‹…m)O(nâ‹…m).Overall time complexity: îˆ»((ğ‘›â‹…ğ‘š)2)O((nâ‹…m)2) per test case.Reminder: don't forget to use __int128 if you didn't handle the numbers carefully! Code (C++)#include <bits/stdc++.h>
#define all(s) s.begin(), s.end()
using namespace std;
using ll = long long;
using ull = unsigned long long;

const int _N = 1e5 + 5;

int T;

void solve() {
	ll n, m, k; cin >> n >> m >> k;
	vector<ll> a(n + 1);
	for (int i = 1; i <= n; i++) cin >> a[i];
	vector<ll> kans(m + 1, LLONG_MAX);
	vector<__int128> f(n + 1), g(n + 1), v(n + 1);
	vector<int> vis(n + 1), L(n + 1), L2(n + 1);
	ll sum = 0;
	for (int i = 1; i <= n; i++) sum += a[i];
	__int128 pans = 0;
	for (int i = 1; i <= n; i++) pans += n * a[i] * a[i];
	auto work = [&](ll s) {
		__int128 ans = pans;
		ans += s * s - 2ll * sum * s;
		f.assign(n + 1, LLONG_MAX);
		g.assign(n + 1, LLONG_MAX);
		for (int i = 1; i <= n; i++) {
			v[i] = n * (2 * a[i] * k + k * k) - 2ll * s * k;
			vis[i] = 0;
		}
		for (int i = 1; i <= m; i++) {
			for (int j = 1; j <= n; j++) {
				L[j] = L2[j] = j;
				if (f[j - 1] < 0) f[j] = f[j - 1] + v[j], L[j] = L[j - 1];
				else f[j] = v[j];
				if (!vis[j]) {
					g[j] = LLONG_MAX;
					continue;
				}
				if (g[j - 1] < 0) g[j] = g[j - 1] + 2ll * n * k * k - v[j], L2[j] = L2[j - 1];
				else g[j] = 2ll * n * k * k - v[j];
			}
			__int128 min_sum = LLONG_MAX;
			int l = 1, r = n, type = 0;
			for (int j = 1; j <= n; j++) {
				if (f[j] < min_sum) {
					min_sum = f[j], r = j, l = L[j];
				}
			}
			for (int j = 1; j <= n; j++) {
				if (g[j] < min_sum) {
					min_sum = g[j], r = j, l = L2[j];
					type = 1;
				}
			}
			ans += min_sum;
			if (type == 0) {
				for (int j = l; j <= r; j++) vis[j]++, v[j] += 2 * n * k * k;
			} else {
				for (int j = l; j <= r; j++) vis[j]--, v[j] -= 2 * n * k * k;
			}
			kans[i] = min((__int128)kans[i], ans);
		}
	};
	
	for (ll x = sum; x <= sum + n * m * k; x += k) {
		work(x);
	}
	for (int i = 1; i <= m; i++) cout << kans[i] << " \n"[i == m];
	return;
}

int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> T;
	while (T--) {
		solve();
	}
} Rate the Problem Amazing problem: 

    


11



 Good problem: 

    


2



 Average problem: 

    


0



 Bad problem: 

    


2



 Didn't solve: 

    


44